Tables in DB:-
Student table -> tbl_student,
student_sequence
course
courseMaterial
teachers
student_course_map
question
answer
content

one_uni_one_f
one_uni_one_s
company
employ
project
validations  -> validations and date


-> StudentRepo - contains quaries
-> CourseRepositoryTest - pagination, pagination with sorting
-> StudentService - throws exception

Guardian is a embadable class embaded in student table

one_uni_one_f <one to one> map with one_uni_one_s
company <one to many> with employ
employ <many to many> with project
question <one to many> with answer
answer <many to many> with content

@GeneratedValue(strategy = <a>)
    <a> -> GenerationType.AUTO  ---> by default
        -> GenerationType.IDENTITY  ---> not the best one from performance point of view
        -> GenerationType.SEQUENCE  ---> generate primary key values and uses a database sequence to generate unique values
        -> GenerationType.TABLE  ---> rarely used, slows down your application

    Eg:- @SequenceGenerator(
                     name = "course_sequency",
                     sequenceName = "course_sequency",
                     allocationSize = 1
             )
          @GeneratedValue(
                     strategy = GenerationType.SEQUENCE,
                     generator = "course_sequency"
             )

    Eg:- @GeneratedValue(strategy = GenerationType.IDENTITY)

Cascade = <a>
    <a> -> CascadeType.ALL
        -> CascadeType.PERSIST
        -> CascadeType.MERGE
        -> CascadeType.REMOVE
        -> CascadeType.REFRESH
        -> CascadeType.DETACH

        above cascade types available in javax.persistence.CascadeType
        below cascade types (hibernate specific once) available in org.hibernate.annotation.CascadeType

    <a> -> CascadeType.REPLICATE
        -> CascadeType.SAVE_UPDATE
        -> CascadeType.LOCK

    CascadeType.ALL ---> propagates all operations

    Eg:- consider person <one to many> relation with address

    CascadeType.PERSIST  ---> When we save the person entity, the address entity will also get saved.

Validations:
    in pom.xml file add spring-boot-starter-validation
    In rest controller -> in function parameter add @Valid  (eg: @Valid @RequestBody Student student)
    In entity add below @s as per need

    @AssertFalse  ->  value of incoming request should be boolean false
    @AsserTrue   ->  value of incoming request should be boolean true
    @Past   ->  It is for date, date should be in past
    @Future  -> It is for date, date should be in future
    @Max(value = 100, message = "the maxvalue should be 100")
    @Min
    @Size(max =100)
    @NotNull
    @Pattern   ->  Incoming value should be match with regular expression


Date format:
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    private Date date;

    -> send date as string in postman

JUnit:-
    some asserts:
        assertEquals(6,result);
        assertTrue(true);
        assertFalse(false);
        assertNull()
        assertNotNull()

    some @:
        @Test -> before test case
        @BeforeEach  -> test runs before every test
        @AfterEach  -> test runs after every test
        @BeforeAll  -> test runs before class (note: class level, static method)
        @AfterAll  -> test runs after class (note: class level, static method)

    Mockito:
        @Mock
        @InjectMocks

        when('methodCall').thenReturn('returnValue');
        when('methodCall').thenReturn('returnValue').thenReturn('returnValue');

Enums:-
    Java Enums are classes that have a fixed set of constants or variables that do not tend to change. Java Enums constants are static and final implicitly.

    enums creates static final Objects for every variable in background
    enums can implements interfaces

    ordinal() -> returns order of obj